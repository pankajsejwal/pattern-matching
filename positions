/*------------------------------------------------------------------------------------------------------*/
load(basic);

/*------------------------------------------------------------------------------------------------------*/
load("C:\\Users\\joker\\Documents\\Maxima-Docs\\segment-new.lisp");

/*------------------------------------------------------------------------------------------------------*/
use_segment(true);

/*------------------------------------------------------------------------------------------------------*/
mapindexed(lis):=block([fin:[],count:0],for item in lis do
                   (count:count+1,push([item,count],fin))
                   ,reverse(fin))$

/*------------------------------------------------------------------------------------------------------*/
assign_positions(lis):=block([ltemp2:[],count:0],
                    for item in lis do if(listp(item)) then 
                       ( 
                    push([assign_positions(item),[count:count+1]],ltemp2))
                    else (push([item,[count:count+1]],ltemp2))
                    ,reverse(ltemp2))$

/*------------------------------------------------------------------------------------------------------*/
call_from_inside(lis):=block([olast:[],temp:0,final:[],prev,final_f:[]],olast:from_inside(lis),
            for item in reverse(final) do (
            if(atom(first(item))) then push(item,final_f) else 
             push([part(tlist,apply(segment,(last(item)))),last(item)],final_f)),reverse(final_f))$

/*------------------------------------------------------------------------------------------------------*/
enum_positions(listt):=block([tlist:listt],call_from_inside(assign_positions(listt)))$

/*------------------------------------------------------------------------------------------------------*/
from_inside(lis):=block([count:0,temps],for item in lis do 
 (if(atom(first(item))) then ( 
 if(olast=[]) then (push(item,final))
 else (push([first(item),flatten(endcons(last(item),reverse(olast)))],final)))
 else ( push([item,flatten(endcons(last(item),reverse(olast)))],final),
 push(last(item),olast),from_inside(first(item)),
 pop(olast))))$

/*------------------------------------------------------------------------------------------------------*/
atlevel(lis,test,[n]):=block([count:1,li:lis,elem:[]],if n=[] then 
                (while(reveal(lis,count)#lis) do count:count+1,n:count),
                for i:1 thru n do (li:apply(append,li),
                elem:append((sublist(li,test)),elem),
                li:sublist(li,listp)),[reverse(elem),li])$

/*------------------------------------------------------------------------------------------------------*/
call_expr_tree(lis):=block([final:[],curr_exp],expr_tree(lis),
                if(final#[]) then (final:map(lambda([x],[cons(first(first(x)),last(first(x))),last(x)]),final),
                finalize_list(final))
                else lis)$

/*------------------------------------------------------------------------------------------------------*/
expr_tree(lis):=block([oper],if(atom(lis)=false) then (oper:op(lis),push([[oper,args(lis)],curr_exp],final),
                  (for i:1 thru length(args(lis)) do (curr_exp:args(lis)[i],expr_tree(args(lis)[i]))))else lis)$

/*------------------------------------------------------------------------------------------------------*/
finalize_list(tt):=block(for item:1 thru length(tt) do ( 
      for i:1 thru length(tt) do ( 
          for j:1 thru length(first(tt[i])) do ( 
            if(last(tt[item])=first(tt[i])[j]) then 
                    first(tt[i])[j]:tt[item][1]))),first(last(tt)))$

/*------------------------------------------------------------------------------------------------------*/
assign_positions_expr(lis):=block([ltemp2:[],count:-1],
                    for item in lis do if(listp(item)) then 
                       (push([assign_positions_expr(item),[count:count+1]],ltemp2))
                    else (push([item,[count:count+1]],ltemp2))
                    ,reverse(ltemp2))$

/*------------------------------------------------------------------------------------------------------*/
call_from_inside(lis):=block([olast:[],temp:0,final:[],prev,final_f:[]],olast:from_inside(lis),
            for item in reverse(final) do (
            if(atom(first(item))) then push(item,final_f) else 
             push([part(tlist,apply(segment,(last(item)))),last(item)],final_f)),reverse(final_f))$

/*------------------------------------------------------------------------------------------------------*/
call_from_inside_expr(lis):=block([final_f:[],olast:[],temp:0,final:[]],olast:from_inside(lis),
            for item in reverse(final) do (
            if(atom(first(item))) then push(item,final_f) else 
             push([part(tlist,apply(segment,(last(item)))),last(item)],final_f)),reverse(final_f))$

/*------------------------------------------------------------------------------------------------------*/
from_inside_expr(lis):=block([count:0],for item in lis do 
                 (if(atom(first(item))) then ( 
                  if(olast=[]) then (push(item,final))
                     else (push([first(item),flatten(endcons(last(item),reverse(olast)))],final)))
                  else (push([first(item),flatten(endcons(last(item),reverse(olast)))],final),
                        push(last(item),olast),from_inside_expr(first(item)),
                  pop(olast))))$

/*------------------------------------------------------------------------------------------------------*/
positions_expr(expr):=block([tlist:expr,temp],temp:call_expr_tree(expr),
                      temp:call_from_inside_expr(assign_positions_expr(temp)),
                      temp)$

/*------------------------------------------------------------------------------------------------------*/
call_analyse(lis):=block([lis:copy(lis),temp:[],backup:[]],temp:analyse(lis),
                 for item in backup do
                 lis:ratsubst(first(item),last(item),lis),lis)$

/*------------------------------------------------------------------------------------------------------*/
analyse(lis):=block([lis:lis],for item in lis do (if(listp(item)) then 
              analyse(item) elseif(atom(item)=false) then 
                 push([call_expr_tree(item),item],backup)),lis)$

/*------------------------------------------------------------------------------------------------------*/
positionsof(elem,lis):=sublist(enum_positions(lis),lambda([x],first(x)=elem))$

